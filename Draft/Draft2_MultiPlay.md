# 😆학습 목표
- 언리얼 엔진을 사용하여 멀티플레이 게임을 제작합니다.
- 서버-클라이언트의 모델과 네트워크 지식, 전반적인 동기화와 관련된 기술을 학습합니다.
- 언리얼 엔진 중급자 및 C++ 개발자라면 누구나 신청하실 수 있습니다.
![image](https://github.com/user-attachments/assets/7325c212-96ef-48d1-8b8e-73f66e860b47)

# 😆예시 화면
![image](https://github.com/user-attachments/assets/830f528b-5bb6-4190-a3ba-4948dc1b19a5)
> 강의 자료로 작성된 실제 게임화면입니다.

# 😆주요 구현 기능
- 세션(로비, 방)의 생성, 삭제, 검색, 참여 등 네트워크 상에서 유저들을 연결시키기
- 게임오브젝트(언리얼의 액터)의 위치 정보 동기화 시키기
- 이벤트가 발생했을 때 다른 유저에게도 동기화시키기
- 특정 정보는 다른 유저에게는 보이지 않게, 나에게만 보이기(체력이나 점수 등)
- 이 정보의 처리 주체 결정하기(서버냐, 클라이언트냐)
- 네트워크 상에서의 최적화 방법
- VPN, SATEM을 활용한 인터넷 환경 등 다양한 네트워크 환경의 게임 만들기
- (Extra)게임 플레이 도중에 약점, 내성, 레벨업, 스킬 해금, 지속시간 등 동적으로 액션을 관리하기
- (Extra)그 외 디버깅 및 분석도구 활용 실습 등
  > Extra 표시 항목은 남은 강의 시간이 있을 때 진행할 예정입니다.

# 😆전체 흐름
- 최초에 한 유저가 방을 생성하면, 다른 유저들에게 해당 방의 목록이 보이면서 참여할 수 있게 됩니다.
- 로비맵에서 서로 눈인사를 하다가, 카운트다운 후 실제 전투맵에서 총구를 겨누게 됩니다.
- 팀의 분배는 인원수에 맞춰 랜덤으로 배정됩니다.
- 경쟁 게임도 만들지만, 서로 협력하는 퍼즐 코옵 게임도 만듭니다.
![image](https://github.com/user-attachments/assets/1a80eb29-8ff0-49ec-98ef-e3e3290adc62)
> 이해를 돕기 위한 AI 이미지입니다.

# 😆상세 일정
| **주차** | **강의주제**       | **학습내용**                                                                                                                                                                  |
|----------|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1        | 환경 구축          | 둠, 퀘이크, 언리얼 토너먼트로 이어진 E-스포츠의 근본 프레임워크를 만나 보세요.                                                                                              |
| 2        | 언리얼 C++         | 이미 C++ 도사라 하더라도 언리얼에서만 사용되는 상용구(BoilerPlate)가 있습니다.<br>소스코드와 언리얼 에디터를 연동하여 개발의 무궁무진한 확장성을 학습합니다.           |
|          | 딜리게이션         | 1000개의 버튼 중 하나의 버튼이 눌렸습니다. 그러나 무엇을 해야 할지 아직 결정되지 않을 수 있습니다.<br>결정될 때까지 기다려야 할까요? 아닙니다. 유연하고 확장 가능한 개발 방법을 학습합니다. |
| 3        | RPC                | 어떤 기능은 서버에서 해야 하며, 클라이언트에서 해야 합니다.<br>왜? 키보드는 서버에 없습니다. 다른 사람은 내 클라이언트에 없습니다. 이 둘은 같지 않습니다.              |
|          | 네트워크 복제      | 내가 열심히 때려도 상대방이 저절로 쓰러지지 않습니다. 어쩌면 승리는 착각일 수도 있습니다.<br>내가 이겼다는 사실을 모두가 동일하게 알리는 방법을 학습합니다.          |
| 4        | 역할               | 사실 나는 한 명이 아닙니다. 나한테 보이는 나, 다른 사람에게 보이는 내가 존재합니다.<br>우리는 각자의 로컬PC에 각자의 메모리가 존재한다는 사실을 알고 있습니다.<br>네트워크는 물리적으로 먼 거리를 가로질러야 합니다. 다른 사람의 메모리에서 어떻게 "나"를 찾아야 할까요? |
| 5        | 네트워크 연결      | 네트워크는 마치 소문을 내는 것과 같습니다. 원하는 걸 찾을 때까지 탐문 수색을 거듭하며 끝내 목적지를 찾습니다.<br>이런 특징이 멀티플레이 게임을 만들 때 고려해야 할 점을 알려줍니다. |
|          | 세션 인터페이스    | 같은 공간에서 같은 게임을 하고 싶은 사람들을 어떻게 모을 수 있을까요?<br>그리고 마음에 안 드는 사람을 어떻게 쫓아낼 수 있을까요?                                         |
| 6        | 전투 구현          | 레드팀과 블루팀을 인원수에 따라 랜덤 배정합니다.<br>친절하게도 죽었을 때 다시 리스폰하여 복수의 기회도 드립니다.                                                         |
| 7        | UI 구현            | 전황을 파악할 수 있는 방법이 필요합니다. 점수 경쟁은 강력한 동기를 부여합니다.<br>여기서 우리는 나 이외에 다른 사람들의 정보를 추가로 습득할 방법을 찾아야 합니다.<br>그리고 아주 멋진 디자인의 UI를 갖고 싶습니다. |
| 8        | 디버깅             | 멀티플레이 환경은 특히 디버깅이 어렵습니다. 코드의 문제인지 환경의 문제인지 알아야 하기 때문이죠.<br>버전 관리는 히스토리 기록 이외에도 협업에 유용한 도구입니다. 입사 전에 사고를 저지르고 예방 주사를 맞아 보세요. |


# 강의 자료
- 강의 자료는 github를 통해 공유합니다.
- 여러분과 의견을 공유하고 소통할 수 있는 채널이 항상 열려 있습니다.
- 여러분이 만든 게임을 언제든지 가져와서 보여주세요!
